#!/usr/bin/env perl
# display a list of files as a tree
use warnings;
use strict;
use Getopt::Long qw(:config bundling no_ignore_case);
use File::Spec;

BEGIN {
	if (eval {require Nullroute::Lib}) {
		Nullroute::Lib->import(qw(_debug _warn _err _die));
	} else {
		$::arg0 = (split m!/!, $0)[-1];
		$::debug = !!$ENV{DEBUG};
		$::warnings = 0;
		$::errors = 0;
		sub _debug { warn "debug: @_\n" if $ENV{DEBUG}; }
		sub _warn  { warn "warning: @_\n"; ++$::warnings; }
		sub _err   { warn "error: @_\n"; ! ++$::errors; }
		sub _die   { _err(@_); exit 1; }
	}
}

my $TERM = (-t 1 ? $ENV{TERM} : undef) // "dumb";

my $TERM256 = $TERM =~ /-256color$/ || $ENV{havecolor} == 256;

my %GRAPH = (
	sm => "│ ",
	im => "├─",
	ie => "└─",
	se => "  ",
	ct => "",
	cs => "",
	cr => "",
);

if ($TERM eq "dumb") {
	$GRAPH{ct} = "";
	$GRAPH{cs} = "";
	$GRAPH{cr} = "";
} elsif ($TERM256) {
	$GRAPH{ct} = "\e[38;5;59m";
	$GRAPH{cs} = "\e[38;5;109m";
	$GRAPH{cr} = "\e[m";
} else {
	$GRAPH{ct} = "\e[36m";
	$GRAPH{cs} = "\e[36m";
	$GRAPH{cr} = "\e[m";
}

my %opt = (
	fakeroot => undef,
	maxdepth => 0,
	noghosts => 0,
	path => undef,
	printfull => 0,
	sep => "/",
);

my $tree = {};
my $seen = {};

sub _dump {
	if ($::debug > 1) {
		use Data::Dumper;
		print Data::Dumper->new([shift])->Indent(1)->Dump;
	}
}

sub canonpath {
	my $path = shift;
	if ($path =~ m|^(\./)|) {
		return $1 . File::Spec->canonpath($path);
	} else {
		return File::Spec->canonpath($path);
	}
}

sub split_path {
	my $path = canonpath(shift);
	my @path;
	for (split(m!\Q$opt{sep}\E+!, $path)) {
		if ($_ eq "")		{ push @path, $opt{sep}; }
		elsif (!@path)		{ push @path, $_; }
		elsif ($_ eq ".")	{ next; }
		elsif ($_ eq "..")	{ pop @path; }
		else			{ push @path, $_; }
	}
	return @path ? @path : $opt{sep};
}

sub walk {
	my ($branch, $path) = @_;
	my @path = split_path($path);
	_debug("walking down '$path' <@path>");
	for (@path) {
		$branch = $branch->{$_} //= {};
	}
	return $branch;
}

sub deepcount {
	my $branch = shift;
	my $count = 0;
	for (values %$branch) {
		$count += 1 + deepcount($_);
	}
	return $count;
}

sub show {
	my $branch = shift // $tree;
	my $depth = shift // 0;
	my $graph = shift // [];
	my $root = shift // "";

	my @keys = sort keys %$branch;
	my $shallow = $opt{maxdepth} && $depth >= $opt{maxdepth};

	$root =~ s!^/+!!;

	while (@keys) {
		my $name = shift @keys;
		my $node = $branch->{$name};

		my $children = keys %$node;
		if ($shallow && $children) {
			$children = deepcount($node);
		}

		my $path = $root ? $root.$opt{sep}.$name : $name;
		my $exists = $opt{noghosts} || exists $seen->{$node};

		$graph->[$depth] = $depth ? @keys ? $GRAPH{im} : $GRAPH{ie} : "";
		print	$GRAPH{ct},
			"@$graph",
			$exists ? "" : "[",
			$exists ? $GRAPH{cr} : $GRAPH{cs},
			$opt{printfull} ? $path : $name,
			$GRAPH{ct},
			$exists ? "" : "]",
			$::debug ? " <$root>" : "",
			($shallow && $children) ? " ($children)" : "",
			$GRAPH{cr},
			"\n";
		next if $shallow;

		$graph->[$depth] = $depth ? @keys ? $GRAPH{sm} : $GRAPH{se} : "";
		show($node, $depth+1, $graph, $path);
	}

	pop @$graph;
}

GetOptions(
	"d|max-depth=i" => \$opt{maxdepth},
	"f|full-names" => \$opt{printfull},
	"g|no-ghosts" => \$opt{noghosts},
	"r|fake-root=s" => \$opt{fakeroot},
	"s|separator=s" => \$opt{sep},
	map {
		$_ => sub { $opt{maxdepth} = ($opt{maxdepth} * 10) + int($_[1]) },
	} 0..9,
) or exit(2);

for (@ARGV) {
	if (/^@(.+)$/) {
		$opt{fakeroot} = $1;
	} else {
		$opt{path} = canonpath($_);
	}
}

while (<STDIN>) {
	chomp;
	my $node = walk($tree, $_);
	$seen->{$node} = 1;
}

while (defined($opt{path}) && $tree->{"."}) {
	$tree = $tree->{"."};
}

my $visible = $tree;
_dump($visible);

if ($opt{path}) {
	_debug("--> descending to '$opt{path}'");
	$visible = {$opt{path} => walk($visible, $opt{path})};
	_dump($visible);
}

if (defined $opt{fakeroot}) {
	_debug("<-- prepending fake '$opt{fakeroot}'");
	$visible = {$opt{fakeroot} => $visible};
	_dump($visible);
}

show($visible);
