#!/usr/bin/env perl
# display a list of files as a tree
no warnings;
use strict;
use File::Spec;

BEGIN {
	if (eval {require Nullroute::Lib}) {
		Nullroute::Lib->import(qw(_debug _warn _err _die));
	} else {
		our ($warnings, $errors);
		sub _debug { warn "debug: @_\n" if $ENV{DEBUG}; }
		sub _warn  { warn "warning: @_\n"; ++$::warnings; }
		sub _err   { warn "error: @_\n"; ! ++$::errors; }
		sub _die   { _err(@_); exit 1; }
	}
}

my $TERM = (-t 1 ? $ENV{TERM} : undef) // "dumb";

my $TERM256 = $TERM =~ /-256color$/ || $ENV{havecolor} == 256;

my %GRAPH = (
	sm => "│ ",
	im => "├─",
	ie => "└─",
	se => "  ",
	ct => "",
	cs => "",
	cr => "",
);

if ($TERM eq "dumb") {
	$GRAPH{ct} = "";
	$GRAPH{cs} = "";
	$GRAPH{cr} = "";
} elsif ($TERM256) {
	$GRAPH{ct} = "\e[38;5;59m";
	$GRAPH{cs} = "\e[38;5;109m";
	$GRAPH{cr} = "\e[m";
} else {
	$GRAPH{ct} = "\e[36m";
	$GRAPH{cs} = "\e[36m";
	$GRAPH{cr} = "\e[m";
}

my $tree = {};
my $items = {};
my $maxdepth = 0;
my $fakeroot;
my $path;

sub canonpath {
	my $path = shift;
	if ($path =~ m|^(\./)|) {
		return $1 . File::Spec->canonpath($path);
	} else {
		return File::Spec->canonpath($path);
	}
}

sub split_path {
	my $path = canonpath(shift);
	my @path;
	for (split(m!/+!, $path)) {
		if ($_ eq ".")     { next; }
		elsif ($_ eq "..") { pop @path; }
		else               { push @path, $_; }
	}
	@path;
}

sub walk {
	my ($branch, $path) = @_;
	_debug("walking down $branch to $path");
	my @path = split_path($path);
	my $head = $fakeroot ? "/".$fakeroot : "";
	_debug("split path: <@path>");
	if (@path) {
		for (@path) {
			_debug("  head <$head> item <$_>");
			$branch = $branch->{$_} //= {};
			$head .= "/".$_;
		}
		_debug("  -> head <$head>");
		$items->{$head} = 1;
	}
	return $branch;
}

sub deepcount {
	my $branch = shift;
	my $count = 0;
	for (values %$branch) {
		$count += 1 + deepcount($_);
	}
	return $count;
}

sub show {
	my $branch = shift // $tree;
	my $depth = shift // 0;
	my $graph = shift // [];
	my $root = shift // "";

	my @keys = sort keys %$branch;
	my $shallow = $maxdepth && $depth >= $maxdepth;

	if ($depth == 1 && !@keys) {
		print	$GRAPH{ct},
			$GRAPH{ie},
			$GRAPH{cs},
			"(empty)",
			$GRAPH{cr},
			"\n";
		return;
	}

	$root =~ s!^/+!!;

	while (@keys) {
		my $item = shift @keys;

		my $children = keys %{$branch->{$item}};
		if ($shallow && $children) {
			$children = deepcount($branch->{$item});
		}

		my $path = $root ? $root."/".$item : $item;
		my $exists = exists $items->{"/".$path};

		$graph->[$depth] = $depth ? @keys ? $GRAPH{im} : $GRAPH{ie} : "";
		print	$GRAPH{ct},
			"@$graph",
			$exists ? "" : "[",
			$exists ? $GRAPH{cr} : $GRAPH{cs},
			$item,
			$GRAPH{ct},
			$exists ? "" : "]",
			($shallow && $children) ? " ($children)" : "",
			$GRAPH{cr},
			"\n";
		next if $shallow;

		$graph->[$depth] = $depth ? @keys ? $GRAPH{sm} : $GRAPH{se} : "";
		show($branch->{$item}, $depth+1, $graph, $path);
	}
	pop @$graph;
}

for (@ARGV) {
	if (/^-(\d+)$/) {
		$maxdepth = $1;
	} elsif (/^@(.+)$/) {
		$fakeroot = $1;
	} else {
		$path = canonpath($_);
	}
}

while (<STDIN>) {
	chomp; walk($tree, $_);
}

while ($path && $tree->{"."}) {
	$tree = $tree->{"."};
}

my $visible = $path ? {$path => walk($tree, $path)}
                    : $tree;

if (defined $fakeroot) {
	$visible = {$fakeroot => $visible};
}

show($visible);
