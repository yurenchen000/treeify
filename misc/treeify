#!/usr/bin/env perl
# treeify - display a list of files as a tree
# (c) 2013-2016 Mantas Mikulėnas <grawity@gmail.com>
# Released under the MIT Expat License (dist/LICENSE.expat)
use v5.10;
use warnings;
use strict;
use Getopt::Long qw(:config bundling no_ignore_case);
use File::Spec;

my %GRAPH = (
	# tree
	sm => "│ ",
	im => "├─",
	ie => "└─",
	se => "  ",
	# ghost nodes
	gp => "[",
	gs => "]",
	# colors
	ct => "",
	cs => "",
	cr => "",
);

my %opt = (
	color => "auto",
	fakeroot => undef,
	maxdepth => 0,
	noghosts => 0,
	path => undef,
	printfull => 0,
	sep => "/",
);

sub canonpath {
	my $path = shift;
	if ($opt{sep} ne "/") {
		return $path;
	} elsif ($path =~ m|^(\./)|) {
		return $1 . File::Spec->canonpath($path);
	} else {
		return File::Spec->canonpath($path);
	}
}

sub split_path {
	my $path = canonpath(shift);
	my @path;
	for (split(m!\Q$opt{sep}\E+!, $path)) {
		if ($_ eq "")		{ push @path, $opt{sep}; }
		elsif (!@path)		{ push @path, $_; }
		elsif ($_ eq ".")	{ next; }
		elsif ($_ eq "..")	{ pop @path; }
		else			{ push @path, $_; }
	}
	return @path ? @path : $opt{sep};
}

sub walk {
	my ($branch, $path) = @_;
	my @path = split_path($path);
	for (@path) {
		$branch = $branch->{$_} //= {};
	}
	return $branch;
}

sub deepcount {
	my ($branch) = @_;
	my $count = 0;
	for (values %$branch) {
		$count += 1 + deepcount($_);
	}
	return $count;
}

sub show {
	my ($branch, $seen, $depth, $graph, $root) = @_;

	$depth //= 0;
	$graph //= [];
	$root  //= "";

	my @keys = sort keys %$branch;
	my $shallow = $opt{maxdepth} && $depth >= $opt{maxdepth};

	while (@keys) {
		my $name = shift @keys;
		my $node = $branch->{$name};

		my $children = keys %$node;
		if ($shallow && $children) {
			$children = deepcount($node);
		}

		my $path = ($root eq $opt{sep}) ? $root.$name
				: ($root ne "") ? $root.$opt{sep}.$name
				: $name;

		my $exists = $opt{noghosts} || exists($seen->{$node});

		$graph->[$depth] = $depth ? @keys ? $GRAPH{im} : $GRAPH{ie} : "";
		print	$GRAPH{ct},
			"@$graph",
			$exists ? "" : $GRAPH{gp},
			$exists ? $GRAPH{cr} : $GRAPH{cs},
			$opt{printfull} ? $path : $name,
			$GRAPH{ct},
			$exists ? "" : $GRAPH{gs},
			($shallow && $children) ? " ($children)" : "",
			$GRAPH{cr},
			"\n";
		next if $shallow;

		$graph->[$depth] = $depth ? @keys ? $GRAPH{sm} : $GRAPH{se} : "";
		show($node, $seen, $depth+1, $graph, $path);
	}

	pop @$graph;
}

sub usage {
	print "$_\n" for
	"Usage: treeify [-d DEPTH] [-f] [-g] [-r ROOT] [-s SEP] [PATH]",
	"",                           #
	"  -d, --max-depth DEPTH      Limit tree depth",
	"  -f, --full-names           Show full names of branches and leaves",
	"  -g, --no-ghosts            Do not highlight 'ghost' branches",
	"  -r, --fake-root PATH       Add a fake root container",
	"  -s, --separator SEP        Split paths at SEP instead of '/'",
	"  PATH                       Only show items under given branch";
}

GetOptions(
	"help" => sub { usage(); exit; },
	"C|color=s" => \$opt{color},
	"d|max-depth=i" => \$opt{maxdepth},
	"f|full-names" => \$opt{printfull},
	"g|no-ghosts" => \$opt{noghosts},
	"r|fake-root=s" => \$opt{fakeroot},
	"s|separator=s" => \$opt{sep},
	map {
		$_ => sub { $opt{maxdepth} = ($opt{maxdepth} * 10) + int($_[0]) },
	} 0..9,
) or exit(2);

for (@ARGV) {
	if (/^@(.+)$/) {
		$opt{fakeroot} = $1;
	} else {
		$opt{path} = canonpath($_);
	}
}

# decide on output features

if ($opt{color} eq "auto") {
	my $term = (-t 1) ? $ENV{TERM} : undef;
	if (!$term || $term eq "dumb") {
		$opt{color} = "off";
	} elsif ($term =~ /-256color$/ || $term =~ /^(xterm|tmux)/) {
		$opt{color} = "256";
	} else {
		$opt{color} = "16";
	}
}

if ($opt{color} eq "256") {
	$GRAPH{ct} = "\e[38;5;59m";
	$GRAPH{cs} = "\e[38;5;109m";
	$GRAPH{cr} = "\e[m";
} elsif ($opt{color} !~ /^(no|off)$/) {
	$GRAPH{ct} = "\e[36m";
	$GRAPH{cs} = "\e[36m";
	$GRAPH{cr} = "\e[m";
} else {
	$GRAPH{ct} = "";
	$GRAPH{cs} = "";
	$GRAPH{cr} = "";
}

# parse input

my $node;
my $tree = {};
my $seen = {};

while (<STDIN>) {
	chomp;
	$node = walk($tree, $_);
	$seen->{$node} = 1;
}

while ($opt{path} && $tree->{"."}) {
	$tree = $tree->{"."};
}

if ($opt{path}) {
	$tree = {$opt{path} => walk($tree, $opt{path})};
}

if ($opt{fakeroot}) {
	$tree = {$opt{fakeroot} => $tree};
}

show($tree, $seen);
